<?xml version="1.0"?>
<syntax name="sourcecode.ruby">
  <zones>
    
    <!-- ============
         = Comments =
         ============ -->
    
    <!-- # A comment -->
    <zone name="comment.line.hash.ruby">
      <expression>(#).*$\n?</expression>
      <capture number="1" name="punctuation.definition.comment.line.begin"/>
    </zone>
    
    <!--
      =begin
      A comment block
      =end
    -->
    <zone name="comment.block.ruby">
      <starts-with>
        <expression>^(=begin).*$</expression>
        <capture number="1" name="punctuation.definition.comment.block.begin"/>
      </starts-with>
      <ends-with>
        <expression>^(=end).*$</expression>
        <capture number="1" name="punctuation.definition.comment.block.end"/>
      </ends-with>
    </zone>
    
    <!-- ======================
         = Syntactical blocks =
         ====================== -->
    
    <!--
      def something(arg1, arg2, arg3)
        
      end
    -->
    <zone name="function.ruby">
      <starts-with>
        <!--
          It's worth noting that this regex will, correctly, fail to match an
          opening paren after a method definition that is *not* followed by a
          closing paren (which raises questions about the possibility and
          handling of multi-line argument lists); however, due to shortcomings
          in the regular expression engine utilized by Espresso (Onigurama),
          it is impossible to look behind for an opening paren when matching
          the closing paren (the Onigurama developer[s] deemed it too
          difficult\costly to implement variable-width lookbehinds, and also
          failed to take into account the fact that a backreference to a
          completed, fixed-width capture, is, in fact, not variable-width).
          
          Therefore, the first and third below will be correctly matched, and
          the second will be correctly ignored, but the last will be
          incorrectly matched:
              
              def something(arg1, arg2, arg3)
              def something(arg1, arg2, arg3
              def something arg1, arg2, arg3
              def something arg1, arg2, arg3)
              
          Any ideas/fixes regarding this annoying bug would be greatly
          appreciated. Here's two alternative regexen bits that would work, if
          Onigurama would support them:
              
              /(?<=.*)\)/
              /(?<=\4)\)/
              
          These would replace the closing-paren match (`/\)/`) near the end,
          in the `parameters.end` capture (`/(\)|\s)/`).
        -->
        <expression>(def)\s+([a-zA-Z_][A-Za-z0-9_-]*)(?:(\s*(?:\((?=.*\))|\s))([^\)]*)(\)|\s))?</expression>
        <capture number="1" name="storage.type.function.block.ruby"/> <!-- horribly unsemantic name for this, damn you TextMate naming conventions! -->
        <capture number="2" name="function.name"/>
        <capture number="3" name="punctuation.definition.parameters.begin"/>
        <capture number="4" name="variable.parameter.function.ruby"/>
        <capture number="5" name="punctuation.definition.parameters.end"/>
      </starts-with>
      <ends-with>
        <expression>end</expression>
        <capture number="0" name="storage.type.function.block.end.ruby"/> <!-- horribly unsemantic name for this, damn you TextMate naming conventions! -->
      </ends-with>
      <subzones>
        <include syntax="sourcecode.ruby"/>
      </subzones>
    </zone>
    
    <!-- ==========================
         = Syntactical constructs =
         ========================== -->
    
    <!-- 'A single-quoted string' -->
    <zone name="string.quoted.single.ruby">
      <starts-with>
        <expression>'</expression>
        <capture number="0" name="punctuation.definition.string.begin.ruby"/>
      </starts-with>
      <ends-with>
        <expression>'</expression>
        <capture number="0" name="punctuation.definition.string.end.ruby"/>
      </ends-with>
      <subzones>
        <zone name="constant.character.escape.ruby">
          <!-- 'A single-quoted string with \'escape sequences\'' -->
          <expression>\\('|\\)</expression>
          <capture number="0" name="punctuation.definition.string.escape.ruby"/>
        </zone>
      </subzones>
    </zone>
    
    <!-- "A double-quoted string" -->
    <zone name="string.quoted.double.ruby">
      <starts-with>
        <expression>"</expression>
        <capture number="0" name="punctuation.definition.string.begin.ruby"/>
      </starts-with>
      <ends-with>
        <expression>"</expression>
        <capture number="0" name="punctuation.definition.string.end.ruby"/>
      </ends-with>
      <subzones>
        <!-- "A double-quoted string with\nescape \"sequences\"" -->
        <zone name="constant.character.escape.ruby">
          <expression>\\(.)</expression>
          <capture number="0" name="punctuation.definition.string.escape.ruby"/>
        </zone>
        
        <!-- "A double-quoted string with #{interpolations}" -->
        <zone name="string.interpolation">
          <starts-with>
            <expression>#\{</expression>
            <capture number="0" name="punctuation.definition.string.interpolation.begin.ruby"/>
          </starts-with>
          <ends-with>
            <expression>\}</expression>
            <capture number="0" name="punctuation.definition.string.interpolation.end.ruby"/>
          </ends-with>
          <subzones>
            <include syntax="sourcecode.ruby"/>
          </subzones>
        </zone>
      </subzones>
    </zone>
    
    <!-- /regular expression/ -->
    <zone name="string.regexp.ruby">
      <starts-with>
        <expression>/</expression>
        <capture number="0" name="punctuation.definition.string.begin.ruby"/>
      </starts-with>
      <ends-with>
        <expression>(/)[igm]*</expression>
        <capture number="1" name="punctuation.definition.string.end.ruby"/>
      </ends-with>
      <subzones>
        <!-- /a regex with\nescape \/sequences\// -->
        <zone name="constant.character.escape.ruby">
          <expression>\\(.)</expression>
          <capture number="0" name="punctuation.definition.string.escape.ruby"/>
        </zone>
        
        <!-- /a regex with(?# comments)/ -->
        <zone name="string.regexp.comment.block.ruby">
          <starts-with>
            <expression>\(\?#</expression>
            <capture number="0" name="punctuation.definition.string.comment.block.begin.ruby"/>
          </starts-with>
          <ends-with>
            <expression>\)</expression>
            <capture number="0" name="punctuation.definition.string.comment.block.end.ruby"/>
          </ends-with>
        </zone>
        
        <!-- /a regex with #{interpolations}/ -->
        <zone name="string.interpolation">
          <starts-with>
            <expression>#\{</expression>
            <capture number="0" name="punctuation.definition.string.interpolation.begin.ruby"/>
          </starts-with>
          <ends-with>
            <expression>\}</expression>
            <capture number="0" name="punctuation.definition.string.interpolation.end.ruby"/>
          </ends-with>
          <subzones>
            <include syntax="sourcecode.ruby"/>
          </subzones>
        </zone>
      </subzones>
    </zone>
    
    <!-- 42, 052, 0x2A -->
    <zone name="constant.numeric.ruby">
      <expression>\b((0(x|X)[0-9a-fA-F]+)|(0[0-7]+)|((0|[1-9][0-9]*)(\.[0-9]+)?(e-?[0-9]+)?))\b</expression>
    </zone>
    
    <!-- ============
         = Keywords =
         ============ -->
    
    <!-- true -->
    <zone name="constant.language.boolean.true.ruby">
      <expression>\btrue\b</expression>
    </zone>
    
    <!-- false -->
    <zone name="constant.language.boolean.false.ruby">
      <expression>\bfalse\b</expression>
    </zone>
    
    <!-- nil -->
    <zone name="constant.language.null.ruby">
      <expression>\bnil\b</expression>
    </zone>
    
    <!-- ========
         = Meta =
         ======== -->
    
    <zone name="punctuation.terminator.statement.ruby">
      <expression>\;</expression>
    </zone>
    <zone name="meta.delimiter.object.comma.ruby">
      <expression>,[ |\t]*</expression>
    </zone>
    <zone name="meta.delimiter.method.period.ruby">
      <expression>\.</expression>
    </zone>
    <zone name="meta.brace.curly.open.ruby">
      <expression>\{</expression>
    </zone>
    <zone name="meta.brace.curly.close.ruby">
      <expression>\}</expression>
    </zone>
    <zone name="meta.brace.round.ruby">
      <expression>\(|\)</expression>
    </zone>
    <zone name="meta.brace.square.ruby">
      <expression>\[|\]</expression>
    </zone>
    
  </zones>
  
  <library>
    <collection name="nothing">
      
    </collection>
  </library>
</syntax>
